import std/[json, os, strutils, strformat]
import database
import analyzer

type
  Indexer* = object
    database*: Database
    analyzer*: Analyzer
    projectPath*: string

proc newIndexer*(database: Database, projectPath: string): Indexer =
  ## Create a new indexer for the given project
  result.database = database
  result.projectPath = projectPath
  result.analyzer = newAnalyzer(projectPath)

proc findNimFiles*(indexer: Indexer, directory: string = ""): seq[string] =
  ## Find all .nim files in the project directory
  let searchDir = if directory == "": indexer.projectPath else: directory
  result = @[]
  
  try:
    for kind, path in walkDir(searchDir):
      case kind:
      of pcFile:
        if path.endsWith(".nim"):
          result.add(path)
      of pcDir:
        # Recursively search subdirectories, but skip common build/cache dirs
        let dirName = extractFilename(path)
        if dirName notin ["nimcache", ".git", "htmldocs", "docs"]:
          result.add(indexer.findNimFiles(path))
      else:
        discard
  except OSError as e:
    echo fmt"Error walking directory {searchDir}: {e.msg}"

proc parseNimDocJson*(indexer: Indexer, jsonOutput: string): int =
  ## Parse nim jsondoc output and store symbols in database
  result = 0
  
  try:
    let docJson = parseJson(jsonOutput)
    
    if not docJson.hasKey("entries"):
      echo "No entries found in nim jsondoc output"
      return 0
    
    let moduleName = if docJson.hasKey("module"): docJson["module"].getStr() else: "unknown"
    
    for entry in docJson["entries"]:
      if not entry.hasKey("name") or not entry.hasKey("type"):
        continue
        
      let name = entry["name"].getStr()
      let symbolType = entry["type"].getStr()
      let line = if entry.hasKey("line"): entry["line"].getInt() else: 0
      let column = if entry.hasKey("column"): entry["column"].getInt() else: 0
      let signature = if entry.hasKey("signature"): entry["signature"].getStr() else: ""
      let documentation = if entry.hasKey("description"): entry["description"].getStr() else: ""
      
      # Determine file path - try to get from entry or use module info
      var filePath = ""
      if entry.hasKey("file"):
        filePath = entry["file"].getStr()
      elif docJson.hasKey("file"):
        filePath = docJson["file"].getStr()
      else:
        filePath = moduleName & ".nim"
      
      # Make file path absolute
      if not isAbsolute(filePath):
        filePath = indexer.projectPath / filePath
      
      let symbolId = indexer.database.insertSymbol(
        name = name,
        symbolType = symbolType,
        module = moduleName,
        filePath = filePath,
        line = line,
        col = column,
        signature = signature,
        documentation = documentation,
        visibility = "" # Will be determined later if needed
      )
      
      if symbolId > 0:
        inc result
        
  except JsonParsingError as e:
    echo fmt"Error parsing JSON: {e.msg}"
  except Exception as e:
    echo fmt"Error processing symbols: {e.msg}"

proc parseNimIdxFile*(indexer: Indexer, idxFilePath: string): int =
  ## Parse a .idx file generated by nim doc --index
  result = 0
  
  if not fileExists(idxFilePath):
    echo fmt"Index file does not exist: {idxFilePath}"
    return 0
  
  try:
    let content = readFile(idxFilePath)
    let lines = content.splitLines()
    
    for line in lines:
      if line.strip() == "":
        continue
        
      # .idx files are tab-separated with 6 fields:
      # entry_type \t name \t file_path \t line \t column \t description
      let parts = line.split('\t')
      if parts.len < 6:
        continue
      
      let entryType = parts[0]
      let name = parts[1] 
      let filePath = parts[2]
      let line = try: parseInt(parts[3]) except: 0
      let column = try: parseInt(parts[4]) except: 0
      let description = parts[5]
      
      # Only process Nim symbols (not markup/headings)
      if entryType in ["nimgrp", "nimsym"]:
        let moduleName = extractFilename(filePath).replace(".nim", "")
        let fullPath = if isAbsolute(filePath): filePath else: indexer.projectPath / filePath
        
        let symbolId = indexer.database.insertSymbol(
          name = name,
          symbolType = entryType,
          module = moduleName,
          filePath = fullPath,
          line = line,
          col = column,
          signature = "",
          documentation = description,
          visibility = ""
        )
        
        if symbolId > 0:
          inc result
          
  except IOError as e:
    echo fmt"Error reading index file {idxFilePath}: {e.msg}"
  except Exception as e:
    echo fmt"Error parsing index file {idxFilePath}: {e.msg}"

proc indexSingleFile*(indexer: Indexer, filePath: string): tuple[success: bool, symbolCount: int] =
  ## Index a single Nim file using nim jsondoc
  try:
    echo fmt"Indexing file: {filePath}"
    
    # Generate JSON documentation for the file
    let absolutePath = if isAbsolute(filePath): filePath else: indexer.projectPath / filePath
    let cmdResult = indexer.analyzer.execNimCommand("jsondoc", @[absolutePath])
    
    if cmdResult.exitCode != 0:
      echo fmt"Failed to generate jsondoc for {filePath}: {cmdResult.output}"
      return (success: false, symbolCount: 0)
    
    # Parse and store the symbols
    let symbolCount = indexer.parseNimDocJson(cmdResult.output)
    
    # Also try to find and parse corresponding .idx file if it exists
    let idxPath = filePath.replace(".nim", ".idx")
    if fileExists(idxPath):
      let idxSymbols = indexer.parseNimIdxFile(idxPath)
      echo fmt"Found {idxSymbols} additional symbols from idx file"
    
    return (success: true, symbolCount: symbolCount)
    
  except Exception as e:
    echo fmt"Error indexing file {filePath}: {e.msg}"
    return (success: false, symbolCount: 0)

proc indexProject*(indexer: Indexer): string =
  ## Index the entire project
  try:
    echo fmt"Starting project indexing for: {indexer.projectPath}"
    
    # Clear existing symbols for this project
    indexer.database.clearSymbols()
    
    # Find all Nim files
    let nimFiles = indexer.findNimFiles()
    echo fmt"Found {nimFiles.len} Nim files"
    
    if nimFiles.len == 0:
      return "No Nim files found in project"
    
    var totalSymbols = 0
    var successCount = 0
    var failureCount = 0
    
    # Index each file
    for filePath in nimFiles:
      let (success, symbolCount) = indexer.indexSingleFile(filePath)
      if success:
        inc successCount
        totalSymbols += symbolCount
        echo fmt"✓ {extractFilename(filePath)}: {symbolCount} symbols"
      else:
        inc failureCount
        echo fmt"✗ Failed to index {extractFilename(filePath)}"
    
    # Try project-wide indexing as well
    echo "Attempting project-wide indexing..."
    let projectResult = indexer.analyzer.execNimCommand("doc", @["--index:on", "--project", indexer.projectPath.absolutePath])
    
    if projectResult.exitCode == 0:
      echo "✓ Project-wide indexing completed"
      
      # Look for generated .idx files
      for kind, path in walkDir(indexer.projectPath):
        if kind == pcFile and path.endsWith(".idx"):
          let idxSymbols = indexer.parseNimIdxFile(path)
          if idxSymbols > 0:
            totalSymbols += idxSymbols
            echo fmt"✓ Processed {extractFilename(path)}: {idxSymbols} symbols"
    else:
      echo fmt"Project-wide indexing failed: {projectResult.output}"
    
    let summary = fmt"""
Project indexing completed:
- Files processed: {successCount}/{nimFiles.len}
- Total symbols indexed: {totalSymbols}
- Failures: {failureCount}
"""
    
    echo summary
    return summary
    
  except Exception as e:
    let errorMsg = fmt"Project indexing failed: {e.msg}"
    echo errorMsg
    return errorMsg

proc updateIndex*(indexer: Indexer, filePaths: seq[string] = @[]): string =
  ## Update index for specific files or detect changes automatically
  try:
    let filesToUpdate = if filePaths.len > 0: filePaths else: indexer.findNimFiles()
    
    var updatedCount = 0
    var totalSymbols = 0
    
    for filePath in filesToUpdate:
      # Check if file was modified since last index
      # For now, we'll just re-index all requested files
      let (success, symbolCount) = indexer.indexSingleFile(filePath)
      if success:
        inc updatedCount
        totalSymbols += symbolCount
    
    return fmt"Updated {updatedCount} files with {totalSymbols} symbols"
    
  except Exception as e:
    return fmt"Index update failed: {e.msg}"